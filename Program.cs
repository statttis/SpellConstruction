using Mutagen.Bethesda;
using Mutagen.Bethesda.FormKeys.SkyrimSE;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;
using System.Text.RegularExpressions;
using SCMod = Mutagen.Bethesda.FormKeys.SkyrimSE.SpellConstruction;

namespace SpellConstruction
{
    public class Program
    {
        private static Lazy<Settings>? _settings = null!;
        private static readonly string _baseName = "SpellConstruction";
        private static readonly ModKey _baseModKey = ModKey.FromNameAndExtension($"{_baseName}.esp");
        private static Dictionary<string, int> _aspectCounts = new Dictionary<string, int>();
        private static HashSet<FormKey> _searchedLeveledLists = new HashSet<FormKey>();
        private static HashSet<FormKey> _leveledListsWithSpellbooks = new HashSet<FormKey>();
        private static HashSet<IBookGetter> _spellbooks = new HashSet<IBookGetter>();
        private static HashSet<IBookGetter> _rareSpellbooks = new HashSet<IBookGetter>();

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddRunnabilityCheck(CheckRunnability)
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings(nickname: "Settings", path: "settings.json", out _settings)
                .SetTypicalOpen(GameRelease.SkyrimSE, $"{_baseName}_Patch.esp")
                .Run(args);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            Console.WriteLine("Getting eligible spell tomes...");
            GetEligibleSpellTomes(state);

            _rareSpellbooks = SpellTomeFilters.ParseSpellTomes(state, _settings.Value.RareSpellTomes).ToHashSet();

            ResetAspectCounts(state);

            Console.WriteLine("Generating spellbook recipes...");
            GenerateSpellbookRecipes(state);

            Console.WriteLine("Generating spellbook breakdown recipes...");
            GenerateSpellbookConstructionRecipes(state);

            Console.WriteLine("Generating armor breakdown recipes...");
            GenerateArmorConstructionRecipes(state);

            Console.WriteLine("Generating scroll breakdown recipes...");
            GenerateScrollConstructionRecipes(state);

            Console.WriteLine("Generating weapon breakdown recipes...");
            GenerateWeaponConstructionRecipes(state);

            Console.WriteLine("Generating skill book breakdown recipes...");
            GenerateSkillBookConstructionRecipes(state);

            Console.WriteLine("Generating ingredient breakdown recipes...");
            GenerateIngredientConstructionRecipes(state);

            Console.WriteLine("Generating ingot breakdown recipes...");
            GenerateIngotConstructionRecipes(state);

            Console.WriteLine("Generating gem breakdown recipes...");
            GenerateGemConstructionRecipes(state);

            PrintAspectCounts();
        }

        public static void ResetAspectCounts(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            _aspectCounts.Clear();
            foreach (var aspect in Aspects.All)
            {
                _aspectCounts.Add(aspect.Book.Resolve(state.LinkCache).EditorID, 0);
            }
        }

        public static void PrintAspectCounts()
        {
            Console.WriteLine("Aspect counts:");
            foreach (var aspectCount in _aspectCounts)
            {
                Console.WriteLine($"{aspectCount.Key}: {aspectCount.Value}");
            }
        }

        public static void GetEligibleSpellTomes(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            if (_settings.Value.FilterSpellTomesByLeveledList)
            {
                foreach (var leveledItem in state.LoadOrder.PriorityOrder.LeveledItem().WinningContextOverrides())
                {
                    GetLeveledItems(state, leveledItem.Record);
                }
            }
            else
            {
                foreach (var book in state.LoadOrder.PriorityOrder.Book().WinningContextOverrides())
                {
                    if (book.Record.Teaches is BookSpell)
                    {
                        _spellbooks.Add(book.Record);
                    }
                }
            }

            _spellbooks = SpellTomeFilters.FilterModExclusions(state, _settings.Value.ModExclusion, _spellbooks);
            _spellbooks = SpellTomeFilters.FilterSpellTomeExclusions(state, _settings.Value.SpellTomeExclusion, _spellbooks);
            _spellbooks = SpellTomeFilters.AddSpellTomeInclusions(state, _settings.Value.SpellTomeInclusion, _spellbooks);

            Console.WriteLine("Eligible spell tomes:");
            foreach (var spellbook in _spellbooks.Select(x => $"{x.FormKey.ModKey}:{x.FormKey.ID.ToString("X8")} - {x.EditorID}").OrderBy(x => x))
            {
                Console.WriteLine(spellbook);
            }
        }

        public static void GenerateSpellbookRecipes(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            int count = 0;
            foreach (var book in _spellbooks)
            {
                if (book.Teaches is BookSpell)
                {
                    var constructionCounts = GetSpellbookConstructions(state, book);
                    if (constructionCounts == null || constructionCounts.Count() < 1)
                    {
                        continue;
                    }

                    var recipe = Conditions.GenerateBaseRecipe(state, book, book.EditorID);

                    var spell = (book.Teaches as BookSpell).Spell.Resolve(state.LinkCache);
                    var (school, expertise) = GetSchoolAndExpertise(spell.HalfCostPerk);

                    Conditions.SetSkillLevelCondition(recipe, school, expertise,
                        _settings.Value.TomesAvailableApprentice, _settings.Value.TomesAvailableAdept, _settings.Value.TomesAvailableExpert, _settings.Value.TomesAvailableMaster);

                    if (_settings.Value.MasterTomesRequireRitualQuest)
                    {
                        Conditions.SetRitualQuestCondition(recipe, school, expertise);
                    }
                    
                    foreach (var constructionCount in constructionCounts)
                    {
                        recipe.Items.Add(new ContainerEntry { Item = new ContainerItem { Count = constructionCount.Count, Item = constructionCount.Construction } });
                        recipe.Conditions.Add(Conditions.GetRequiredCountCondition(constructionCount.Construction));
                    }

                    count++;
                }
            }

            Console.WriteLine($"Recipes generated for {count} spellbooks");
        }

        public static void GenerateSpellbookConstructionRecipes(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            int count = 0;
            foreach (var book in state.LoadOrder.PriorityOrder.Book().WinningContextOverrides())
            {
                if (book.Record.Teaches is BookSpell)
                {
                    var constructionCounts = GetSpellbookConstructions(state, book.Record);
                    if (constructionCounts == null || constructionCounts.Count() < 1)
                    {
                        continue;
                    }

                    for (int i = 0; i < constructionCounts.Count(); i++)
                    {
                        var recipe = Conditions.GenerateBaseRecipe(state, constructionCounts.ElementAt(i).Construction.Resolve(state.LinkCache), $"SpellbookConstruction{i}{book.Record.EditorID}");
                        recipe.Items.Add(new ContainerEntry { Item = new ContainerItem { Count = 1, Item = new FormLink<IBookGetter>(book.Record) } });
                        recipe.Conditions.Add(Conditions.GetRequiredCountCondition(new FormLink<IItemGetter>(book.Record)));
                        recipe.Conditions.Add(Conditions.GetSpellKnownCondition((book.Record.Teaches as BookSpell).Spell));
                    }

                    count++;
                }
            }

            Console.WriteLine($"Breakdown recipes generated for {count} spellbooks");
        }

        public static void GenerateArmorConstructionRecipes(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            int count = 0;
            foreach (var armor in state.LoadOrder.PriorityOrder.Armor().WinningContextOverrides())
            {
                if (!armor.Record.ObjectEffect.IsNull)
                {
                    // skip items that can't be disenchanted
                    if (armor.Record.Keywords != null && armor.Record.Keywords.Any(k => k.FormKey == Skyrim.Keyword.MagicDisallowEnchanting.FormKey))
                    {
                        continue;
                    }

                    var constructions = GetAspectConstructions(state, armor.Record.ObjectEffect.Resolve<IObjectEffectGetter>(state.LinkCache).Effects,
                        _settings.Value.ArmorAspects, _settings.Value.ArmorAspects, $"{armor.Record.FormKey.ModKey} - {armor.Record.EditorID}").ToList();

                    if (constructions == null || constructions.Count() < 1)
                    {
                        continue;
                    }

                    constructions.Add(new ConstructionCount { Construction = SCMod.Book.SCConstructionSelf, Count = 1 });

                    for (int i = 0; i < constructions.Count(); i++)
                    {
                        var recipe = Conditions.GenerateBaseRecipe(state, constructions.ElementAt(i).Construction.Resolve(state.LinkCache), $"ArmorConstruction{i}{armor.Record.EditorID}");
                        recipe.Items.Add(new ContainerEntry { Item = new ContainerItem { Count = 1, Item = new FormLink<IItemGetter>(armor.Record) } });
                        recipe.Conditions.Add(Conditions.GetRequiredCountCondition(new FormLink<IItemGetter>(armor.Record)));
                        recipe.Conditions.Add(Conditions.GetObjectEffectKnownCondition(armor.Record.ObjectEffect.Resolve<IObjectEffectGetter>(state.LinkCache)));
                    }

                    count++;
                }
            }

            Console.WriteLine($"Breakdown recipes generated for {count} armors");
        }

        public static void GenerateScrollConstructionRecipes(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            int count = 0;
            foreach (var scroll in state.LoadOrder.PriorityOrder.Scroll().WinningContextOverrides())
            {
                var constructions = GetAspectConstructions(state, scroll.Record.Effects, _settings.Value.ScrollAspects, _settings.Value.ScrollAspects,
                    $"{scroll.Record.FormKey.ModKey} - {scroll.Record.EditorID}").ToList();

                if (constructions == null || constructions.Count() < 1)
                {
                    continue;
                }

                constructions.Add(new ConstructionCount { Construction = GetTargetTypeConstruction(scroll.Record.TargetType), Count = 1 });

                for (int i = 0; i < constructions.Count(); i++)
                {
                    var recipe = Conditions.GenerateBaseRecipe(state, constructions.ElementAt(i).Construction.Resolve(state.LinkCache), $"ScrollConstruction{i}{scroll.Record.EditorID}");
                    recipe.Items.Add(new ContainerEntry { Item = new ContainerItem { Count = 1, Item = new FormLink<IItemGetter>(scroll.Record) } });
                    recipe.Conditions.Add(Conditions.GetRequiredCountCondition(new FormLink<IItemGetter>(scroll.Record)));
                }

                count++;
            }

            Console.WriteLine($"Breakdown recipes generated for {count} scrolls");
        }

        public static void GenerateWeaponConstructionRecipes(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            int count = 0;
            foreach (var weapon in state.LoadOrder.PriorityOrder.Weapon().WinningContextOverrides())
            {
                if (!weapon.Record.ObjectEffect.IsNull)
                {
                    // skip items that can't be disenchanted
                    if (weapon.Record.Keywords != null && weapon.Record.Keywords.Any(k => k.FormKey == Skyrim.Keyword.MagicDisallowEnchanting.FormKey))
                    {
                        continue;
                    }

                    var constructions = GetAspectConstructions(state, weapon.Record.ObjectEffect.Resolve<IObjectEffectGetter>(state.LinkCache).Effects,
                        _settings.Value.WeaponAspects, _settings.Value.WeaponAspects, $"{weapon.Record.FormKey.ModKey} - {weapon.Record.EditorID}").ToList();

                    if (constructions == null || constructions.Count() < 1)
                    {
                        continue;
                    }

                    bool requireEffectKnown = true;
                    FormLink<IBookGetter> targetConstruction;
                    switch (weapon.Record.Data.AnimationType)
                    {
                        case WeaponAnimationType.Bow:
                        case WeaponAnimationType.Crossbow:
                            targetConstruction = SCMod.Book.SCConstructionTarget;
                            break;
                        case WeaponAnimationType.Staff:
                            requireEffectKnown = false;
                            targetConstruction = SCMod.Book.SCConstructionTarget;
                            break;
                        default:
                            targetConstruction = SCMod.Book.SCConstructionTouch;
                            break;
                    }

                    constructions.Add(new ConstructionCount { Construction = targetConstruction, Count = 1 });

                    for (int i = 0; i < constructions.Count(); i++)
                    {
                        var recipe = Conditions.GenerateBaseRecipe(state, constructions.ElementAt(i).Construction.Resolve(state.LinkCache), $"WeaponConstruction{i}{weapon.Record.EditorID}");
                        recipe.Items.Add(new ContainerEntry { Item = new ContainerItem { Count = 1, Item = new FormLink<IItemGetter>(weapon.Record) } });
                        recipe.Conditions.Add(Conditions.GetRequiredCountCondition(new FormLink<IItemGetter>(weapon.Record)));
                        if (requireEffectKnown)
                        {
                            recipe.Conditions.Add(Conditions.GetObjectEffectKnownCondition(weapon.Record.ObjectEffect.Resolve<IObjectEffectGetter>(state.LinkCache)));
                        }
                    }

                    count++;
                }
            }

            Console.WriteLine($"Breakdown recipes generated for {count} weapons");
        }

        public static void GenerateSkillBookConstructionRecipes(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            int count = 0;
            foreach (var book in state.LoadOrder.PriorityOrder.Book().WinningContextOverrides())
            {
                if (book.Record.Teaches as BookSkill != null)
                {
                    var skill = (book.Record.Teaches as BookSkill).Skill.Value;
                    int requiredAspects = _settings.Value.SkillBookAspects;
                    switch (skill)
                    {
                        case Skill.Alteration:
                        case Skill.Conjuration:
                        case Skill.Destruction:
                        case Skill.Illusion:
                        case Skill.Restoration:
                            GenerateSkillBookSchoolConstructionRecipe(state, book.Record, skill);
                            requiredAspects--;
                            break;
                        default:
                            break;
                    }

                    GenerateSkillBookAspectConstructionRecipes(state, book.Record, requiredAspects);

                    count++;
                }
            }

            Console.WriteLine($"Breakdown recipes generated for {count} skill books");
        }

        public static void GenerateIngredientConstructionRecipes(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            int count = 0;
            var usableIngredients = state.PatchMod.FormLists.GetOrAddAsOverride(SCMod.FormList.SCUsableIngredients.Resolve(state.LinkCache));
            foreach (var ingredient in state.LoadOrder.PriorityOrder.Ingredient().WinningContextOverrides())
            {
                if (ingredient.Record.Value < _settings.Value.IngredientMinimumValue)
                {
                    continue;
                }

                if (ingredient.Record.Effects == null || ingredient.Record.Effects.Count > 4)
                {
                    Console.WriteLine($"Ingredient does not have 4 or fewer effects: {ingredient.Record.FormKey.ModKey} - {ingredient.Record.EditorID}");
                    continue;
                }

                usableIngredients.Items.Add(ingredient.Record.ToLink());
                

                for (int i = 0; i < ingredient.Record.Effects.Count; i++)
                {
                    var construction = GetAspectConstructions(state, new List<IEffectGetter>() { ingredient.Record.Effects[i] }, 1, 1,
                        $"{ingredient.Record.FormKey.ModKey} - {ingredient.Record.EditorID}").First().Construction;
                    var requiredCount = Math.Max(Math.Min((int)(_settings.Value.IngredientRequiredValue / Math.Max(GetItemValue(ingredient.Record), 1)), _settings.Value.IngredientMaximumQuantity), _settings.Value.IngredientMinimumQuantity);
                    var recipe = Conditions.GenerateBaseRecipe(state, construction.Resolve(state.LinkCache), $"Ingredient{i}{ingredient.Record.EditorID}");
                    recipe.Items.Add(new ContainerEntry { Item = new ContainerItem { Count = requiredCount, Item = ingredient.Record.ToLink<IItemGetter>() } });
                    recipe.Conditions.Add(Conditions.GetRequiredCountCondition(ingredient.Record.ToLink<IItemGetter>()));
                    recipe.Conditions.Add(Conditions.GetEffectKnownCondition(ingredient.Record, i));
                }

                count++;
            }

            Console.WriteLine($"Breakdown recipes generated for {count} ingredients");
        }

        public static void GenerateGemConstructionRecipes(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            int count = 0;
            foreach (var intention in Materials.Intentions.Concat(Materials.Methods))
            {
                GenerateItemConstructionRecipes(state, intention.Book, intention.Materials, _settings.Value.IntentionMethodRequiredValue,
                    _settings.Value.IntentionMethodMaximumQuantity, _settings.Value.IntentionMethodMinimumQuantity);

                count++;
            }

            Console.WriteLine($"Breakdown recipes generated for {count} gems");
        }

        public static void GenerateIngotConstructionRecipes(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            int count = 0;
            foreach (var fundamental in Materials.Fundamentals)
            {
                GenerateItemConstructionRecipes(state, fundamental.Book, fundamental.Materials, _settings.Value.FundamentalRequiredValue,
                    _settings.Value.FundamentalMaximumQuantity, _settings.Value.FundamentalMinimumQuantity);

                count++;
            }

            Console.WriteLine($"Breakdown recipes generated for {count} ingots");
        }

        public static void GenerateItemConstructionRecipes(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, IFormLink<IBookGetter> construction,
            IEnumerable<IFormLink<IItemGetter>> items, int requiredValue, int maximumCount, int minimumCount)
        {
            foreach (var item in items)
            {
                var count = Math.Max(Math.Min((int)(requiredValue / Math.Max(GetItemValue(item.Resolve(state.LinkCache)), 1)), maximumCount), minimumCount);
                var recipe = Conditions.GenerateBaseRecipe(state, construction.Resolve(state.LinkCache), $"Material{item.Resolve(state.LinkCache).EditorID}");
                recipe.Items.Add(new ContainerEntry { Item = new ContainerItem { Count = count, Item = item } });
                recipe.Conditions.Add(Conditions.GetRequiredCountCondition(item));
            }
        }

        public static IEnumerable<ConstructionCount> GetSpellbookConstructions(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, IBookGetter book)
        {
            var spell = (book.Teaches as BookSpell).Spell.Resolve(state.LinkCache);

            if (spell.HalfCostPerk.IsNull)
            {
                Console.WriteLine($"Spell without half cost perk: {spell.FormKey.ModKey} - {spell.EditorID}");
                return null;
            }

            var constructions = new List<ConstructionCount>();

            var (school, expertise) = GetSchoolAndExpertise(spell.HalfCostPerk);

            constructions.Add(new ConstructionCount{ Construction = GetSchoolConstruction(school), Count = 1});
            constructions.Add(new ConstructionCount { Construction = GetCastTypeConstruction(spell.CastType), Count = 1 });
            constructions.Add(new ConstructionCount { Construction = GetTargetTypeConstruction(spell.TargetType), Count = 1 });

            var (requiredAspects, requiredUniqueAspects) = GetRequiredAspectCount(expertise);

            if (_rareSpellbooks.Contains(book))
            {
                requiredAspects = (int)(requiredAspects * _settings.Value.RareSpellTomeMultiplier);
            }

            constructions.AddRange(GetAspectConstructions(state, spell.Effects, requiredAspects, requiredUniqueAspects, $"{spell.FormKey.ModKey} - {spell.EditorID}"));

            return constructions;
        }

        public static IEnumerable<ConstructionCount> GetAspectConstructions(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, IReadOnlyList<IEffectGetter> effects, int requiredAspects, int requiredUniqueAspects, string debugInfo)
        {
            var constructions = new List<ConstructionCount>();
            var aspectScores = Aspects.All.Select(a => new AspectScore { Aspect = a, Score = 0 }).ToList();
            foreach (var effect in effects.Select(e => e.BaseEffect.Resolve(state.LinkCache)))
            {
                SetMagicEffectOrderedAspectScores(state, aspectScores, effect);
            }

            var aspects = aspectScores.OrderByDescending(x => x.Score).Take(requiredUniqueAspects).Where(x => x.Score > 0);

            if (!aspects.Any())
            {
                Console.WriteLine($"No matching aspects for {debugInfo}");
            }

            foreach (var aspect in aspects)
            {
                constructions.Add(new ConstructionCount { Construction = aspect.Aspect.Book, Count = 1 });
                _aspectCounts[aspect.Aspect.Book.Resolve(state.LinkCache).EditorID] += 1;
            }

            // add additional by percentage if necessary
            if (aspects.Count() < requiredAspects)
            {
                int remainingRequiredAspects = requiredAspects - aspects.Count();
                int initialRemainingRequiredAspects = remainingRequiredAspects;
                int totalScore = aspects.Sum(a => a.Score);
                for (int i = 0; i < aspects.Count(); i++)
                {
                    var percentage = (float)aspects.ElementAt(i).Score / (float)totalScore;
                    var additionalCount = Math.Min(initialRemainingRequiredAspects, (int)Math.Round((float)remainingRequiredAspects * percentage, 0, MidpointRounding.ToPositiveInfinity));
                    initialRemainingRequiredAspects -= additionalCount;
                    constructions.ElementAt(i).Count += additionalCount;
                    if (initialRemainingRequiredAspects < 1)
                    {
                        break;
                    }
                }
            }

            // debug
            if (constructions.Sum(x => x.Count) != requiredAspects)
            {
                Console.WriteLine($"Incorrect number of items (required: {requiredAspects}, has: {constructions.Sum(x => x.Count)}) for {debugInfo}");
            }

            return constructions;
        }

        public static FormLink<IBookGetter> GetSchoolConstruction(Skill school)
        {
            switch (school)
            {
                case Skill.Alteration:
                    return SCMod.Book.SCConstructionAlteration;
                case Skill.Conjuration:
                    return SCMod.Book.SCConstructionConjuration;
                case Skill.Destruction:
                    return SCMod.Book.SCConstructionDestruction;
                case Skill.Illusion:
                    return SCMod.Book.SCConstructionIllusion;
                case Skill.Restoration:
                    return SCMod.Book.SCConstructionRestoration;
                default:
                    throw new Exception($"Unexpected skill: {school}");
            }
        }

        public static (Skill, SkillLevel) GetSchoolAndExpertise(IFormLinkGetter<IPerkGetter> halfCostPerk)
        {
            if (halfCostPerk.FormKey.ID == Skyrim.Perk.AlterationNovice00.FormKey.ID)
            {
                return (Skill.Alteration, SkillLevel.Novice);
            }

            if (halfCostPerk.FormKey.ID == Skyrim.Perk.AlterationApprentice25.FormKey.ID)
            {
                return (Skill.Alteration, SkillLevel.Apprentice);
            }

            if (halfCostPerk.FormKey.ID == Skyrim.Perk.AlterationAdept50.FormKey.ID)
            {
                return (Skill.Alteration, SkillLevel.Adept);
            }

            if (halfCostPerk.FormKey.ID == Skyrim.Perk.AlterationExpert75.FormKey.ID)
            {
                return (Skill.Alteration, SkillLevel.Expert);
            }

            if (halfCostPerk.FormKey.ID == Skyrim.Perk.AlterationMaster100.FormKey.ID)
            {
                return (Skill.Alteration, SkillLevel.Master);
            }

            if (halfCostPerk.FormKey.ID == Skyrim.Perk.ConjurationNovice00.FormKey.ID)
            {
                return (Skill.Conjuration, SkillLevel.Novice);
            }

            if (halfCostPerk.FormKey.ID == Skyrim.Perk.ConjurationApprentice25.FormKey.ID)
            {
                return (Skill.Conjuration, SkillLevel.Apprentice);
            }

            if (halfCostPerk.FormKey.ID == Skyrim.Perk.ConjurationAdept50.FormKey.ID)
            {
                return (Skill.Conjuration, SkillLevel.Adept);
            }

            if (halfCostPerk.FormKey.ID == Skyrim.Perk.ConjurationExpert75.FormKey.ID)
            {
                return (Skill.Conjuration, SkillLevel.Expert);
            }

            if (halfCostPerk.FormKey.ID == Skyrim.Perk.ConjurationMaster100.FormKey.ID)
            {
                return (Skill.Conjuration, SkillLevel.Master);
            }

            if (halfCostPerk.FormKey.ID == Skyrim.Perk.DestructionNovice00.FormKey.ID)
            {
                return (Skill.Destruction, SkillLevel.Novice);
            }

            if (halfCostPerk.FormKey.ID == Skyrim.Perk.DestructionApprentice25.FormKey.ID)
            {
                return (Skill.Destruction, SkillLevel.Apprentice);
            }

            if (halfCostPerk.FormKey.ID == Skyrim.Perk.DestructionAdept50.FormKey.ID)
            {
                return (Skill.Destruction, SkillLevel.Adept);
            }

            if (halfCostPerk.FormKey.ID == Skyrim.Perk.DestructionExpert75.FormKey.ID)
            {
                return (Skill.Destruction, SkillLevel.Expert);
            }

            if (halfCostPerk.FormKey.ID == Skyrim.Perk.DestructionMaster100.FormKey.ID)
            {
                return (Skill.Destruction, SkillLevel.Master);
            }

            if (halfCostPerk.FormKey.ID == Skyrim.Perk.IllusionNovice00.FormKey.ID)
            {
                return (Skill.Illusion, SkillLevel.Novice);
            }

            if (halfCostPerk.FormKey.ID == Skyrim.Perk.IllusionApprentice25.FormKey.ID)
            {
                return (Skill.Illusion, SkillLevel.Apprentice);
            }

            if (halfCostPerk.FormKey.ID == Skyrim.Perk.IllusionAdept50.FormKey.ID)
            {
                return (Skill.Illusion, SkillLevel.Adept);
            }

            if (halfCostPerk.FormKey.ID == Skyrim.Perk.IllusionExpert75.FormKey.ID)
            {
                return (Skill.Illusion, SkillLevel.Expert);
            }

            if (halfCostPerk.FormKey.ID == Skyrim.Perk.IllusionMaster100.FormKey.ID)
            {
                return (Skill.Illusion, SkillLevel.Master);
            }

            if (halfCostPerk.FormKey.ID == Skyrim.Perk.RestorationNovice00.FormKey.ID)
            {
                return (Skill.Restoration, SkillLevel.Novice);
            }

            if (halfCostPerk.FormKey.ID == Skyrim.Perk.RestorationApprentice25.FormKey.ID)
            {
                return (Skill.Restoration, SkillLevel.Apprentice);
            }

            if (halfCostPerk.FormKey.ID == Skyrim.Perk.RestorationAdept50.FormKey.ID)
            {
                return (Skill.Restoration, SkillLevel.Adept);
            }

            if (halfCostPerk.FormKey.ID == Skyrim.Perk.RestorationExpert75.FormKey.ID)
            {
                return (Skill.Restoration, SkillLevel.Expert);
            }

            if (halfCostPerk.FormKey.ID == Skyrim.Perk.RestorationMaster100.FormKey.ID)
            {
                return (Skill.Restoration, SkillLevel.Master);
            }

            throw new Exception($"Unexpected half cost perk: {halfCostPerk}");
        }

        public static void GenerateSkillBookSchoolConstructionRecipe(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, IBookGetter book, Skill skill)
        {
            var recipe = Conditions.GenerateBaseRecipe(state, GetSchoolConstruction(skill).Resolve(state.LinkCache), $"SkillBookSchool{book.EditorID}");
            recipe.Items.Add(new ContainerEntry { Item = new ContainerItem { Count = 1, Item = new FormLink<IItemGetter>(book) } });
            recipe.Conditions.Add(Conditions.GetRequiredCountCondition(new FormLink<IItemGetter>(book)));
        }

        public static void GenerateSkillBookAspectConstructionRecipes(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, IBookGetter book, int requiredAspects)
        {
            var scores = Aspects.All.Select(a => new AspectScore { Aspect = a, Score = GetPhraseMatchScore(book.BookText.String, a.Phrases) }).OrderByDescending(x => x.Score);
            var aspects = scores.Take(requiredAspects).Where(x => x.Score > 0).Select(x => x.Aspect);
            foreach (var aspect in aspects)
            {
                var construction = aspect.Book.Resolve(state.LinkCache);
                var recipe = Conditions.GenerateBaseRecipe(state, construction, $"SkillBookAspect{construction.EditorID}{book.EditorID}");
                recipe.Items.Add(new ContainerEntry { Item = new ContainerItem { Count = 1, Item = new FormLink<IItemGetter>(book) } });
                recipe.Conditions.Add(Conditions.GetRequiredCountCondition(new FormLink<IItemGetter>(book)));
                _aspectCounts[aspect.Book.Resolve(state.LinkCache).EditorID] += 1;
            }
        }

        public static (int, int) GetRequiredAspectCount(SkillLevel skillLevel)
        {
            switch (skillLevel)
            {
                case SkillLevel.Novice:
                    return (_settings.Value.NoviceAspects, _settings.Value.NoviceUniqueAspects);
                case SkillLevel.Apprentice:
                    return (_settings.Value.ApprenticeAspects, _settings.Value.ApprenticeUniqueAspects);
                case SkillLevel.Adept:
                    return (_settings.Value.AdeptAspects, _settings.Value.AdeptUniqueAspects);
                case SkillLevel.Expert:
                    return (_settings.Value.ExpertAspects, _settings.Value.ExpertUniqueAspects);
                case SkillLevel.Master:
                    return (_settings.Value.MasterAspects, _settings.Value.MasterUniqueAspects);
                default:
                    throw new Exception($"Unexpected SkillLeve: {skillLevel}");
            }
        }

        public static void SetMagicEffectOrderedAspectScores(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, IEnumerable<AspectScore> aspectScores, IMagicEffectGetter magicEffect)
        {
            // bug in mutagen?
            if (magicEffect.Keywords != null && magicEffect.Keywords.Count > 100)
            {
                Console.WriteLine($"Unable to handle MGEF {magicEffect.FormKey.ModKey} - {magicEffect.EditorID}; skipping aspect scoring");
                return;
            }

            foreach (var aspectScore in aspectScores)
            {
                // keywords - exact match and phrase match
                if (magicEffect.Keywords != null)
                {
                    foreach (var keyword in magicEffect.Keywords)
                    {
                        if (aspectScore.Aspect.Keywords.Contains(keyword))
                        {
                            aspectScore.Score += _settings.Value.ScoreMatchingKeyword;
                        }

                        aspectScore.Score += GetPhraseMatchScore(keyword.Resolve(state.LinkCache).EditorID, aspectScore.Aspect.Phrases);
                    }
                }

                // archetype and actor value match
                if (aspectScore.Aspect.ActorValueRequiement == ActorValueRequirement.None)
                {
                    if (aspectScore.Aspect.Archetypes.Contains(magicEffect.Archetype.Type))
                    {
                        aspectScore.Score += _settings.Value.ScoreMatchingArchetype;
                    }

                    if (aspectScore.Aspect.ActorValues.Contains(magicEffect.Archetype.ActorValue))
                    {
                        aspectScore.Score += _settings.Value.ScoreMatchingActorValue;
                    }

                    if (aspectScore.Aspect.ActorValues.Contains(magicEffect.SecondActorValue))
                    {
                        aspectScore.Score += _settings.Value.ScoreMatchingActorValue;
                    }
                }
                else
                {
                    AddActorValueRequirementScore(aspectScore, magicEffect, aspectScore.Aspect.ActorValueRequiement);
                }

                // phrase match on editor id and various optional properties
                aspectScore.Score += GetPhraseMatchScore(magicEffect.EditorID, aspectScore.Aspect.Phrases);

                if (magicEffect.Name != null)
                {
                    aspectScore.Score += GetPhraseMatchScore(magicEffect.Name.String, aspectScore.Aspect.Phrases);
                }

                if (magicEffect.Description != null)
                {
                    aspectScore.Score += GetPhraseMatchScore(magicEffect.Description.String, aspectScore.Aspect.Phrases);
                }

                if (!magicEffect.CastingLight.IsNull)
                {
                    aspectScore.Score += GetPhraseMatchScore(magicEffect.CastingLight?.Resolve(state.LinkCache)?.EditorID, aspectScore.Aspect.Phrases);
                }

                if (!magicEffect.HitShader.IsNull)
                {
                    aspectScore.Score += GetPhraseMatchScore(magicEffect.HitShader?.Resolve(state.LinkCache)?.EditorID, aspectScore.Aspect.Phrases);
                }

                if (!magicEffect.HitEffectArt.IsNull)
                {
                    aspectScore.Score += GetPhraseMatchScore(magicEffect.HitEffectArt?.Resolve(state.LinkCache)?.EditorID, aspectScore.Aspect.Phrases);
                }

                if (!magicEffect.EnchantShader.IsNull)
                {
                    aspectScore.Score += GetPhraseMatchScore(magicEffect.EnchantShader?.Resolve(state.LinkCache)?.EditorID, aspectScore.Aspect.Phrases);
                }

                if (!magicEffect.Projectile.IsNull)
                {
                    aspectScore.Score += GetPhraseMatchScore(magicEffect.Projectile?.Resolve(state.LinkCache)?.EditorID, aspectScore.Aspect.Phrases);
                }
            }
        }

        public static void AddActorValueRequirementScore(AspectScore aspectScore, IMagicEffectGetter magicEffect, ActorValueRequirement actorValueRequirement)
        {
            if (aspectScore.Aspect.Archetypes.Contains(magicEffect.Archetype.Type))
            {
                bool meetsActorValueRequirement;
                switch (actorValueRequirement)
                {
                    case ActorValueRequirement.PositiveHeal:
                        meetsActorValueRequirement = !magicEffect.Flags.HasFlag(MagicEffect.Flag.Detrimental)
                                                  && !magicEffect.Flags.HasFlag(MagicEffect.Flag.Recover);
                        break;
                    case ActorValueRequirement.PositiveBuff:
                        meetsActorValueRequirement = !magicEffect.Flags.HasFlag(MagicEffect.Flag.Detrimental)
                                                  && magicEffect.Flags.HasFlag(MagicEffect.Flag.Recover);
                        break;
                    case ActorValueRequirement.NegativeDamage:
                        meetsActorValueRequirement = magicEffect.Flags.HasFlag(MagicEffect.Flag.Detrimental)
                                                  && !magicEffect.Flags.HasFlag(MagicEffect.Flag.Recover);
                        break;
                    case ActorValueRequirement.NegativeDebuff:
                        meetsActorValueRequirement = magicEffect.Flags.HasFlag(MagicEffect.Flag.Detrimental)
                                                  && magicEffect.Flags.HasFlag(MagicEffect.Flag.Recover);
                        break;
                    default:
                        meetsActorValueRequirement = false;
                        break;
                }

                if (meetsActorValueRequirement)
                {
                    var matchingActorValue = aspectScore.Aspect.ActorValues.Contains(magicEffect.Archetype.ActorValue);
                    var matchingSecondActorValue = aspectScore.Aspect.ActorValues.Contains(magicEffect.SecondActorValue);

                    if (matchingActorValue || matchingSecondActorValue)
                    {
                        aspectScore.Score += _settings.Value.ScoreMatchingArchetype;
                    }

                    if (matchingActorValue)
                    {
                        aspectScore.Score += _settings.Value.ScoreMatchingActorValue;
                    }

                    if (matchingSecondActorValue)
                    {
                        aspectScore.Score += _settings.Value.ScoreMatchingActorValue;
                    }
                }
            }
        }

        public static int GetPhraseMatchScore(string property, IEnumerable<string> phrases)
        {
            if (string.IsNullOrWhiteSpace(property))
            {
                return 0;
            }

            return phrases.Sum(p => Regex.Matches(property, p, RegexOptions.IgnoreCase).Count * _settings.Value.ScoreMatchingPhrase);
        }

        public static FormLink<IBookGetter> GetCastTypeConstruction(CastType castType)
        {
            switch (castType)
            {
                case CastType.Concentration:
                    return SCMod.Book.SCConstructionConcentration;
                case CastType.FireAndForget:
                    return SCMod.Book.SCConstructionFireAndForget;
                default:
                    throw new Exception($"Unexpected cast type: {castType}");
            }
        }

        public static FormLink<IBookGetter> GetTargetTypeConstruction(TargetType targetType)
        {
            switch (targetType)
            {
                case TargetType.Self:
                    return SCMod.Book.SCConstructionSelf;
                case TargetType.Aimed:
                case TargetType.TargetActor:
                case TargetType.TargetLocation:
                    return SCMod.Book.SCConstructionTarget;
                case TargetType.Touch:
                    return SCMod.Book.SCConstructionTouch;
                default:
                    throw new Exception($"Unexpected target type: {targetType}");
            }
        }

        public static uint GetItemValue(IItemGetter item)
        {
            switch (item)
            {
                case IAmmunitionGetter i:
                    return i.Value;
                case IArmorGetter i:
                    return i.Value;
                case IBookGetter i:
                    return i.Value;
                case IIngestibleGetter i:
                    return i.Value;
                case IIngredientGetter i:
                    return i.Value;
                case IMiscItemGetter i:
                    return i.Value;
                case IScrollGetter i:
                    return i.Value;
                case ISoulGemGetter i:
                    return i.Value;
                case IWeaponBasicStatsGetter i:
                    return i.Value;
                default:
                    return 0;
            }
        }

        public static void CheckRunnability(IRunnabilityState state)
        {
            state.LoadOrder.AssertListsMod(_baseModKey);
        }

        public class AspectScore
        {
            public Aspect Aspect { get; set; }
            public int Score { get; set; }
        }

        public class ConstructionCount
        {
            public IFormLink<IBookGetter> Construction { get; set; }
            public int Count { get; set; }
        }

        public static void GetLeveledItems(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, ILeveledItemGetter leveledItem)
        {
            if (leveledItem.Entries == null)
            {
                return;
            }

            foreach (var entry in leveledItem.Entries)
            {
                var item = entry.Data.Reference.Resolve(state.LinkCache);
                if (item as IBookGetter != null)
                {
                    if ((item as IBookGetter).Teaches is BookSpell)
                    {
                        _leveledListsWithSpellbooks.Add(leveledItem.FormKey);
                        _spellbooks.Add(item as IBookGetter);
                    }
                }

                var leveledItemNested = entry.Data.Reference.Resolve(state.LinkCache) as ILeveledItemGetter;
                if (leveledItemNested != null)
                {
                    if (_searchedLeveledLists.Add(leveledItemNested.FormKey))
                    {
                        GetLeveledItems(state, leveledItemNested);
                    }
                }
            }
        }
    }
}
